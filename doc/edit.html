<body class="focus-tail"><h1 operator="" id="editing">Editing</h1><h2 id="editing-primitives">Editing primitives</h2><p>Lisp programs are expected to use the following primitives to edit the Neomacs DOM. These primitives provides <a href="positions.html">positions</a>-based interface and handles text-node splitting and merging automatically. These primitives also maintain <a href="undo.html">undo</a> history, update renderer-side DOM,  manage setup and destruction of observers and computed attributes, and allocate <code>neomacs-identifier</code>'s.</p><dl><dt>Function: <code>delete-nodes</code> <code>(beg end)</code></dt><dd>Delete nodes between BEG and END and returns nil.</dd><dd>BEG and END must be sibling positions.  If END is nil, delete children
starting from BEG till the end of its parent.</dd><dt>Function: <code>extract-nodes</code> <code>(beg end)</code></dt><dd>Like <code>delete-nodes</code>, but clone and return the deleted contents.</dd><dt>Function: <code>insert-nodes</code> <code>(marker-or-pos &amp;rest things)</code></dt><dd>Insert THINGS at MARKER-OR-POS.</dd><dd>THINGS can be DOM nodes or strings, which are converted to text nodes.</dd><dt>Function: <code>move-nodes</code> <code>(beg end to)</code></dt><dd>Move nodes between BEG and END to TO and returns nil.</dd><dd>BEG and END must be sibling positions.  If END is nil, move children
starting from BEG till the end of its parent.</dd></dl><h2 id="editing-hooks">Editing hooks</h2><p>More often than not the structured data in a buffer only makes sense if they follow certain constraints or invariants. Neomacs provides a number of facilities to help enforcing invariants, including <a href="dom.html#attributes">computed attributes</a>, <a href="command-loop.html#buffer-transactions">pre/post command hooks</a> and the following facilities.</p><p>Catch all nodes entering and leaving a buffer's DOM:</p><dl><dt>Progn generic function: <code>on-node-setup</code> <code>(buffer node)</code></dt><dd>Run some action when NODE is inserted into BUFFER.</dd><dd>NODE can be either an <code>element</code> or a <code>text-node</code>.</dd><dt>Progn generic function: <code>on-node-cleanup</code> <code>(buffer node)</code></dt><dd>Run some action when NODE is removed from BUFFER.</dd><dd>NODE can be either an <code>element</code> or a <code>text-node</code>.</dd></dl><p>Schedule some action to run after current command invocation if a node is edited:</p><dl><dt>Macro: <code>with-post-command</code> <code>((node &amp;rest slots) &amp;body body)</code></dt><dd>Run BODY at the end of current command, if any SLOTS of NODE is
changed.</dd></dl><p>Typically, <code>on-node-setup</code> is used to register some computed attributes and post command actions depending on type of node being inserted. <code>with-post-command</code> should be used to restore invariants instead of adding observers (via <code>lwcells</code>'s <code>add-observer</code>) that directly edits the DOM, because observers can run in the middle of compound editing operations and commands which might cause unpredictable behavior.</p><h2 id="compound-editing-operations">Compound editing operations</h2><p>Functions implemented using <a href="#editing-primitives">editing primitives</a>, provided for convenience:</p><dl><dt>Function: <code>splice-node</code> <code>(node)</code></dt><dd>Splice children of NODE in place of NODE itself.</dd><dt>Function: <code>join-nodes</code> <code>(dst src)</code></dt><dd>Join DST and SRC nodes.</dd><dd>This moves all children of SRC into DST and deletes SRC.</dd><dt>Function: <code>raise-node</code> <code>(node)</code></dt><dd>Replace NODE's parent with NODE.</dd><dt>Function: <code>split-node</code> <code>(&amp;optional (pos (focus)))</code></dt><dd>Split node containing POS at POS.</dd><dd>Let parent be the node containing POS. This involves inserting a clone
of parent after parent, and moving children after POS into the
clone. Returns the cloned node (i.e. the node after the split point).</dd><dt>Function: <code>wrap-node</code> <code>(node new-node)</code></dt><dd>Insert NEW-NODE around NODE.</dd><dd>NODE become the last child of NEW-NODE.</dd><dt>Function: <code>delete-node</code> <code>(node)</code></dt><dd>Delete a single NODE.</dd><dt>Function: <code>replace-node</code> <code>(node new-node)</code></dt><dd>Replace NODE with NEW-NODE.</dd></dl><h2 id="editing-commands">Editing commands</h2><p>The following generic editing commands are avaliable in any Neomacs buffer:</p><dl><dt>Command (<code>enter</code>): <code>new-line</code> <code>(&amp;optional (marker (focus)))</code></dt><dd>Insert a new line node (br element) at MARKER.</dd><dt>Command (<code>backspace</code>): <code>backward-delete</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Command (<code>C-d</code>): <code>forward-delete</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Command (<code>M-backspace</code>): <code>backward-delete-word</code> <code>(&amp;optional (marker (focus)))</code></dt><dt>Command (<code>space, !, &quot;, #, $, %, &amp;, ', (, ), *, +, ,, -, ., /, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, :, ;, &lt;, =, &gt;, ?, @, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, [, \, ], ^, _, `, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, {, |, }, ~,  , ¡, ¢, £, ¤, ¥, ¦, §, ¨, ©, ª, «, ¬, ­, ®, ¯, °, ±, ², ³, ´, µ, ¶, ·, ¸, ¹, º, », ¼, ½, ¾, ¿, À, Á, Â, Ã, Ä, Å, Æ, Ç, È, É, Ê, Ë, Ì, Í, Î, Ï, Ð, Ñ, Ò, Ó, Ô, Õ, Ö, ×, Ø, Ù, Ú, Û, Ü, Ý, Þ, ß, à, á, â, ã, ä, å, æ, ç, è, é, ê, ë, ì, í, î, ï, ð, ñ, ò, ó, ô, õ, ö, ÷, ø, ù, ú, û, ü, ý, þ</code>): <code>self-insert-command</code> <code>()</code></dt><dd>Insert the last typed character into current buffer.</dd></dl><h2 id="the-clipboard">The clipboard</h2><dl><dt>Variable: <code>*clipboard-ring*</code></dt><dt>Variable: <code>*clipboard-ring-index*</code></dt></dl><h2 id="clipboard-commands">Clipboard commands</h2><dl><dt>Command (<code>C-w</code>): <code>cut-element</code> <code>()</code></dt><dd>Cut element under focus and save into clipboard.</dd><dd>If selection is active, cut selected contents instead.</dd><dt>Command (<code>M-w</code>): <code>copy-element</code> <code>()</code></dt><dd>Copy element under focus into clipboard.</dd><dd>If selection is active, copy selected contents instead.</dd><dt>Command (<code>C-y</code>): <code>paste</code> <code>()</code></dt><dd>Paste the first item in clipboard.</dd><dt>Command (<code>M-y</code>): <code>paste-pop</code> <code>()</code></dt><dd>Cycle pasted contents, or prompt for a clipboard item to paste.</dd><dt>Command (<code>C-k</code>): <code>forward-cut</code> <code>(&amp;optional (pos (focus)))</code></dt><dd>Cut until end of line and save into clipboard.</dd></dl></body>