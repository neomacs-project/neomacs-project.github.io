<!DOCTYPE html>
<html><head><style id="neomacs-style-COMMON">@import url("neomacs://sys/space-mono/space-mono.css");

@import url("neomacs://sys/cmu-concrete/cmu-concrete.css");

@import url("neomacs://sys/dejavu-sans-mono/dejavu-sans-mono.css");</style><style id="neomacs-style-BUFFER">body{
    font-family: CMU Concrete;
    color: #54454d;
}

.focus{
    background-color: rgba(169,151,160,0.1);
}

.focus-tail{
    background-color: rgba(169,151,160,0.1);
}

.focus-tail::after{
    content: " ";
    display: inline-block;
    white-space: pre-wrap;
    width: 0.4em;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.range-selection{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

code{
    font-family: monospace;
}

:link{
    font-family: CMU Concrete;
    color: #54454d;
}

.invisible{
    display: none;
}

::highlight(neomacs){
    position: absolute;
    min-height: 1em;
    min-width: 0.3em;
    z-index: -1;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

::highlight(neomacs-range){
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

#neomacs-cursor{
    position: absolute;
    min-height: 1em;
    min-width: 0.3em;
    z-index: -1;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

::-webkit-scrollbar{
    display: none;
}</style><style id="neomacs-style-DOC-MODE">body{
    left: 0;
    right: 0;
    white-space: pre-wrap;
    padding-left: 1em;
}

body.focus-tail::after{
    content: "  ";
    white-space: pre;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}</style><style id="neomacs-style-LISP-MODE">.symbol{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
}

.symbol:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}



.symbol:empty::after{
    content: "_";
}

.symbol:empty:not(:last-child){
    margin-right: 0.4em;
}

.symbol:empty.focus-tail::after{
    content: "_";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    color: #a997a0;
}

.string::before{
    content: "\"";
}

.string::after{
    content: "\"";
}

.string:not(:last-child){
    margin-right: 0.4em;
}

.string.focus::before{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string.focus-tail::after{
    content: "\"";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.object{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    text-decoration: underline;
}

.object:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.symbol[symbol-type="ghost"]{
    margin-right: 0!important;
}

.symbol[symbol-type="macro"][operator]{
    color: #d29fa8;
}

.symbol[symbol-type="keyword"]{
    color: #d29fa8;
}

.symbol[symbol-type="special-operator"][operator]{
    color: #d29fa8;
}

.list{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    padding-left: 0.4em;
}

.list::before{
    content: "(";
    margin-left: -0.4em;
}

.list::after{
    content: ")";
    vertical-align: bottom;
}

.list:not(:last-child){
    margin-right: 0.4em;
}

.list.focus-tail::after{
    content: ")";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.list.focus::before{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.list:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.comment{
    display: inline-block;
    white-space: pre-wrap;
}

.comment::after{
    content: "‚Å£";
}

.comment[comment-level="1"]{
    position: sticky;
    left: 20em;
    border-left: 0.3rem solid #a997a0;
    padding-left: 0.3rem;
    color: #a997a0;
}

.comment[comment-level="2"]{
    border-left: 0.3rem solid #a997a0;
    padding-left: 0.3rem;
    color: #a997a0;
}

.comment[comment-level="3"]{
    font-size: 1.2em;
    color: #a997a0;
}

.comment[comment-level="3"]::before{
    content: "";
    display: list-item;
    position: absolute;
}

.comment[comment-level="4"]{
    font-size: 1.1em;
    color: #a997a0;
}

.comment[comment-level="4"]::before{
    content: "";
    display: list-item;
    position: absolute;
}

[compiler-note-severity="note"]{
    border: solid 1px rgba(169,151,160,1.0);
}

[compiler-note-severity="style-warning"]{
    border: dashed 1px rgba(240,0,120,1.0);
}

[compiler-note-severity="warning"]{
    border: solid 1px rgba(240,0,120,1.0);
}

[compiler-note-severity="error"]{
    border: double 1px rgba(240,0,120,1.0);
}</style><style id="neomacs-style-HTML-DOC-MODE">:empty::after{
    content: "_";
}

li p{
    margin: 0;
}

body{
    white-space: normal;
    max-width: 48rem;
    text-align: justify;
    hyphens: auto;
}

.comma-expr::before{
    content: ",";
}

.comma-expr{
    border: solid 1px currentColor;
}</style></head><body><h1 operator="" class="" id="motion">Motion</h1><h2 id="selectable-positions">Selectable positions</h2><p>Neomacs try to keep the focus at selectable positions after every command invocation. The direction of this post-command adjustment is controlled by <code>adjust-marker-direction</code>. Programs can also call <code>ensure-selectable</code> to adjust marker positions. Note the difference between <code>(ensure-selectable (focus) t) and  <code>(setf (adjust-marker-direction (current-buffer)) &#39;backward)</code></code>: the former adjust focus backwards directly, while the latter let the command loop adjust backward after <a href="command-loop.html#buffer-transactions">post-command hooks</a> and <a href="edit.html#editing-hooks">post-command actions</a>.</p><dl><dt>Function: <code>selectable-p</code> <code>( . pos)</code></dt><dd>Test if POS is selectable.</dd><dt>Standard generic function: <code>selectable-p-aux</code> <code>(buffer . pos)</code></dt><dd>Extension point for <code>selectable-p</code>.</dd><dd>Test if POS is selectable in BUFFER.</dd><dt>Standard generic function, setf-able: <code>adjust-marker-direction</code> <code>( . object)</code></dt><dt>Function: <code>ensure-selectable</code> <code>(marker&amp;optional . (backward (eql (adjust-marker-direction (host marker)) (quote backward))))</code></dt><dd>Move MARKER to nearest selectable position.</dd><dd>Prefer going forward if BACKWARD is nil. Prefer going backward
otherwise. Default behavior depends on MARKER&#39;s host buffer&#39;s
<code>adjust-marker-direction</code> slot.</dd></dl><h2 id="motion-by-nodes-and-elements">Motion by nodes and elements</h2><dl><dt>Command (<code>arrow-right, C-f</code>): <code>forward-node</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to closest selectable preorder successor.</dd><dt>Command (<code>arrow-left, C-b</code>): <code>backward-node</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to closest selectable preorder predecessor.</dd><dt>Command: <code>forward-node-cycle</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Like <code>forward-node</code>, but may wrap around to beginning of buffer.</dd><dt>Command: <code>backward-node-cycle</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Like <code>backward-node</code>, but may wrap around to beginning of buffer.</dd><dt>Command: <code>forward-element</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to first element (excluding line break) to the right.</dd><dt>Command (<code>C-M-b</code>): <code>backward-element</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to first element (excluding line break) to the left.</dd><dt>Command: <code>backward-up-node</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to closest selectable parent.</dd></dl><h2 id="top-level-motion">Top-level motion</h2><dl><dt>Command (<code>M-a</code>): <code>beginning-of-defun</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to current or previous toplevel node.</dd><dt>Command (<code>M-e</code>): <code>end-of-defun</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to next toplevel node.</dd><dt>Command (<code>M-&lt;</code>): <code>beginning-of-buffer</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to beginning of buffer.</dd><dt>Command (<code>M-&gt;</code>): <code>end-of-buffer</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to end of buffer.</dd></dl><h2 id="word-motion">Word motion</h2><dl><dt>Standard generic function, setf-able: <code>word-boundary-list</code> <code>( . object)</code></dt><dt>Function: <code>word-character-p</code> <code>(buffer . node)</code></dt><dd>Test if NODE is a word constituent character in BUFFER.</dd><dt>Function: <code>word-start-p</code> <code>( . pos)</code></dt><dd>Test if POS is at start of a word.</dd><dt>Function: <code>word-end-p</code> <code>( . pos)</code></dt><dd>Test if POS is at end of a word.</dd></dl><p>Word motion commands:</p><dl><dt>Command (<code>M-arrow-right, M-f</code>): <code>forward-word</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to next word end position.</dd><dt>Command (<code>M-arrow-left, M-b</code>): <code>backward-word</code> <code>(&amp;optional . (marker (focus) non-interactive))</code></dt><dd>Move to previous word start position.</dd></dl><h2 id="line-motion">Line motion</h2><p>Test if position is at line boundary:</p><dl><dt>Function: <code>block-element-p</code> <code>( . element)</code></dt><dd>Test if ELEMENT is a block element.</dd><dt>Standard generic function: <code>block-element-p-aux</code> <code>(buffer . element)</code></dt><dd>Extension point for <code>block-element-p</code>.</dd><dd>Test if ELEMENT is a block element in BUFFER.</dd><dt>Function: <code>line-start-p</code> <code>( . pos)</code></dt><dd>Test if POS is at start of a line.</dd><dt>Function: <code>line-end-p</code> <code>( . pos)</code></dt><dd>Test if POS is at end of a line.</dd></dl><p>Move to line boundary:</p><dl><dt>Command (<code>home, C-a</code>): <code>beginning-of-line</code> <code>(&amp;optional . (marker (focus)))</code></dt><dd>Move to beginning of line.</dd><dd>Also returns number of skipped selectable position, useful for
non-interactive use.</dd><dt>Command (<code>end, C-e</code>): <code>end-of-line</code> <code>(&amp;optional(marker (focus)) . interactive)</code></dt><dd>Move to end of line.</dd></dl><p>The following commands try to keep horizontal location approximately the same. Currently, we do this by counting the number of selectable positions between current focus position and beginning-of-line position, and try to keep that number the same.</p><dl><dt>Command (<code>arrow-up, C-p</code>): <code>previous-line</code> <code>(&amp;optional(n 1) . (marker (focus)))</code></dt><dd>Move to N-th previous line.</dd><dd>Try to keep horizontal location approximately the same.</dd><dt>Command (<code>arrow-down, C-n</code>): <code>next-line</code> <code>(&amp;optional(n 1) . (marker (focus)))</code></dt><dd>Move to N-th next line.</dd><dd>Try to keep horizontal location approximately the same.</dd><dt>Standard generic function, setf-able: <code>scroll-lines</code> <code>( . object)</code></dt><dt>Command (<code>page-up, M-v</code>): <code>scroll-up-command</code> <code>( nil)</code></dt><dd>Move up <code>scroll-lines</code>.</dd><dt>Command (<code>page-down, C-v</code>): <code>scroll-down-command</code> <code>( nil)</code></dt><dd>Move down <code>scroll-lines</code>.</dd></dl>
</body></html>