<!DOCTYPE html>
<html><head><style id="neomacs-style-COMMON">@import url("neomacs://sys/space-mono/space-mono.css");

@import url("neomacs://sys/cmu-concrete/cmu-concrete.css");

@import url("neomacs://sys/dejavu-sans-mono/dejavu-sans-mono.css");</style><style id="neomacs-style-BUFFER">body{
    font-family: CMU Concrete;
    color: #54454d;
}

.focus{
    background-color: rgba(169,151,160,0.1);
}

.focus-tail{
    background-color: rgba(169,151,160,0.1);
}

.focus-tail::after{
    content: " ";
    display: inline-block;
    white-space: pre-wrap;
    width: 0.4em;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.range-selection{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

code{
    font-family: monospace;
}

:link{
    font-family: CMU Concrete;
    color: #54454d;
}

.invisible{
    display: none;
}

::highlight(neomacs){
    position: absolute;
    min-height: 1em;
    min-width: 0.3em;
    z-index: -1;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

::highlight(neomacs-range){
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

#neomacs-cursor{
    position: absolute;
    min-height: 1em;
    min-width: 0.3em;
    z-index: -1;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

::-webkit-scrollbar{
    display: none;
}</style><style id="neomacs-style-DOC-MODE">body{
    left: 0;
    right: 0;
    white-space: pre-wrap;
    padding-left: 1em;
}

body.focus-tail::after{
    content: "  ";
    white-space: pre;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}</style><style id="neomacs-style-LISP-MODE">.symbol{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
}

.symbol:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}



.symbol:empty::after{
    content: "_";
}

.symbol:empty:not(:last-child){
    margin-right: 0.4em;
}

.symbol:empty.focus-tail::after{
    content: "_";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    color: #a997a0;
}

.string::before{
    content: "\"";
}

.string::after{
    content: "\"";
}

.string:not(:last-child){
    margin-right: 0.4em;
}

.string.focus::before{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string.focus-tail::after{
    content: "\"";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.string:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.object{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    text-decoration: underline;
}

.object:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.symbol[symbol-type="ghost"]{
    margin-right: 0!important;
}

.symbol[symbol-type="macro"][operator]{
    color: #d29fa8;
}

.symbol[symbol-type="keyword"]{
    color: #d29fa8;
}

.symbol[symbol-type="special-operator"][operator]{
    color: #d29fa8;
}

.list{
    display: inline-block;
    vertical-align: top;
    position: relative;
    white-space: pre;
    padding-left: 0.4em;
}

.list::before{
    content: "(";
    margin-left: -0.4em;
}

.list::after{
    content: ")";
    vertical-align: bottom;
}

.list:not(:last-child){
    margin-right: 0.4em;
}

.list.focus-tail::after{
    content: ")";
    width: auto;
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.list.focus::before{
    background-color: rgba(169,151,160,0.5);
    color: #54454d;
}

.list:not(:last-child):not(.focus-tail){
    margin-right: 0.4em;
}

.comment{
    display: inline-block;
    white-space: pre-wrap;
}

.comment::after{
    content: "‚Å£";
}

.comment[comment-level="1"]{
    position: sticky;
    left: 20em;
    border-left: 0.3rem solid #a997a0;
    padding-left: 0.3rem;
    color: #a997a0;
}

.comment[comment-level="2"]{
    border-left: 0.3rem solid #a997a0;
    padding-left: 0.3rem;
    color: #a997a0;
}

.comment[comment-level="3"]{
    font-size: 1.2em;
    color: #a997a0;
}

.comment[comment-level="3"]::before{
    content: "";
    display: list-item;
    position: absolute;
}

.comment[comment-level="4"]{
    font-size: 1.1em;
    color: #a997a0;
}

.comment[comment-level="4"]::before{
    content: "";
    display: list-item;
    position: absolute;
}

[compiler-note-severity="note"]{
    border: solid 1px rgba(169,151,160,1.0);
}

[compiler-note-severity="style-warning"]{
    border: dashed 1px rgba(240,0,120,1.0);
}

[compiler-note-severity="warning"]{
    border: solid 1px rgba(240,0,120,1.0);
}

[compiler-note-severity="error"]{
    border: double 1px rgba(240,0,120,1.0);
}</style><style id="neomacs-style-HTML-DOC-MODE">:empty::after{
    content: "_";
}

li p{
    margin: 0;
}

body{
    white-space: normal;
    max-width: 48rem;
    text-align: justify;
    hyphens: auto;
}

.comma-expr::before{
    content: ",";
}

.comma-expr{
    border: solid 1px currentColor;
}</style></head><body><h1 operator="" class="" id="window-management">Window management</h1><p>Neomacs manage windows using <i>frame-root</i> buffers -- the window tree in Neomacs is itself a buffer! Selecting windows are implemented by moving focus in the frame-root buffer. Creating and removing windows are implemented by editing the frame-root buffer. This is one of the many nice things about  computing environment inside a structural editor, which wouldn&#39;t be possible in, say, a text editor.</p><h2 id="window-management-commands">Window management commands</h2><p>Selecting a different window:</p><dl><dt>Command (<code>C-x o</code>): <code>other-window</code> <code>( nil)</code></dt><dd>Focus another buffer in cyclic order in current frame.</dd><dt>Command: <code>prev-other-window</code> <code>( nil)</code></dt><dd>Focus another buffer in reverse cyclic order in current frame.</dd></dl><p>Deleting windows:</p><dl><dt>Command (<code>C-x 0</code>): <code>close-window</code> <code>(&amp;optional . (buffer (current-buffer)))</code></dt><dd>Close the window which displays BUFFER.</dd><dd>If BUFFER is the only displayed buffer in a frame, this functions do
nothing instead, because deleting it would break window management.</dd><dt>Command (<code>C-x 1</code>): <code>delete-other-windows</code> <code>(&amp;optional . (buffer (current-buffer)))</code></dt><dd>Make BUFFER fill its frame.</dd></dl><p>Splitting windows:</p><dl><dt>Command (<code>C-x 3</code>): <code>split-window-right</code> <code>(&amp;optional . (buffer (replacement-buffer)))</code></dt><dd>Split a window to the right and display BUFFER in it.</dd><dt>Command (<code>C-x 2</code>): <code>split-window-below</code> <code>(&amp;optional . (buffer (replacement-buffer)))</code></dt><dd>Split a window to the bottom and display BUFFER in it.</dd></dl><h2 id="echo-area">Echo area</h2><p>Neomacs frames display a small buffer at the bottom to display messages.</p><dl><dt>Function: <code>message</code> <code>(control-string&amp;rest . format-arguments)</code></dt><dd>Echo and log a message in <code>*Messages*</code> buffer.</dd><dd>If CONTROL-STRING is a string, format it with FORMAT-ARGUMENTS and
echo it.</dd><dd>CONTROL-STRING can also be a list of DOM nodes (<code>element</code>s or
<code>text-node</code>s), which are displayed and logged. FORMAT-ARGUMENTS must
be nil in this case.</dd><dt>Variable: <code>*message-log-max*</code></dt><dd>Maximum number of lines to keep in the <code>*Messages*</code> buffer.</dd><dd>If nil, disable message logging. If t, log messages but don&#39;t truncate
<code>*Messages*</code> buffer.</dd></dl><h2 id="frame-root-buffers">Frame-root buffers</h2><p>Frame-root buffers are buffers with <code>frame-root-mode</code> enabled and manages Neomacs windows, which in turn displays other buffers. <code>frame-root-mode</code> expect buffer content to follow certain conventions:</p><dl><dt operator="">CSS class: <code>content</code></dt><dd>Elements of this class correspond one-to-one to buffers displayed in this frame. Such element must have a <code>buffer</code> CSS attribute, which is the ID of the buffer being displayed.</dd><dt>CSS class: <code>main</code></dt><dd>This CSS class must be used together with the <code>content</code> CSS class. It marks the corresponding buffer as the main buffer for the containing window. A <code>buffer</code> or <code>minibuffer</code> element must have exactly one descendant with this class.</dd><dt>CSS class: <code>buffer</code></dt><dd>A window for displaying a full-sized buffer. It must have exactly one <code>main</code> descendant. It may have multiple <code>content</code> descendants, the ones without <code>main</code> CSS class display child buffers.</dd><dt>CSS class: <code>vertical-child-container</code></dt><dd>Must be a child of a <code>buffer</code> element and must contain <code>main</code> element. Including an <code>vertical-child-container</code> element in a <code>buffer</code> element allows it to support displaying vertically-split child buffers (i.e. on the left or right side), which are inserted as children of the <code>vertical-child-container</code> element.</dd><dt>CSS class: <code>minibuffer</code></dt><dd>A window for displaying small buffers, used for echo-areas and minibuffers without completion lists (note that minibuffers with completion lists are normally displayed in <code>buffer</code> elements).</dd><dt>CSS attribute: <code>selectable</code></dt><dd>Window management commands may select an element only if this attribute is present.</dd><dt>CSS class: <code>vertical</code></dt><dd>Vertical split container. Children should be <code>buffer</code> elements, which are displayed side-by-side.</dd><dt>CSS class: <code>horizontal</code></dt><dd>Horizontal split container. Children should be <code>buffer</code> or <code>minibuffer</code> elements, which are displayed row-by-row.</dd></dl><h2 id="window-decorations">Window decorations</h2><p>Besides <code>content</code> elements that display buffer contents, <code>buffer</code> and <code>minibuffer</code> elements can have other children, which are rendered normally by the frame-root buffer. These elements are used to draw window decorations like header lines.</p><dl><dt>Standard generic function: <code>window-decoration-aux</code> <code>( . buffer)</code></dt><dd>Create window-decoration for BUFFER.</dd><dd>Should return a <code>div</code> with <code>buffer</code> or <code>minibuffer</code> CSS class, which
contains a single descendant with both <code>main</code> and <code>content</code> CSS
class. This descendant must have a <code>buffer</code> CSS attribute with the
<code>id</code> of BUFFER as its value.</dd><dd>Child buffers can be included via other elements with <code>content</code> CSS
class.</dd><dt>Function: <code>update-window-decoration-field</code> <code>(buffername . text)</code></dt><dd>Update the element with CSS class NAME in BUFFER&#39;s window decoration.</dd><dd>There must be exactly one element with NAME as CSS class, whose
content is replaced with TEXT. If BUFFER is not displayed, this
function does nothing.</dd><dt>Standard generic function, setf-able: <code>window-decoration</code> <code>( . object)</code></dt></dl>
</body></html>