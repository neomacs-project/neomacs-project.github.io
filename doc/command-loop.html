<body class="focus-tail"><h1 operator="" id="command-loop">Command Loop</h1><dl><dt>Function: <code>start-command-loop</code> <code>()</code></dt><dd>Start Neomacs command loop.</dd><dd>If a command loop is already running, ask and wait for it to quit
before starting a new one. This is useful when you want changes to the
function <code>command-loop</code> to take effect.</dd></dl><h2 id="command-dispatch">Command dispatch</h2><dl><dt>Variable: <code>*this-command*</code></dt><dd>Current command run by command loop.</dd><dd>The value is bound to nil outside command invocation made by command
loop.</dd><dt>Variable: <code>*this-command-keys*</code></dt><dd>List of keys that cause current command to run.</dd><dd>The value is bound to nil outside command invocation made by command
loop.</dd><dt>Variable: <code>*last-command*</code></dt><dd>Last command run by command loop.</dd></dl><h2 id="buffer-transactions">Buffer transactions</h2><p>Neomacs commands are processed in a transactional manner, following  the 2PL (2-phase locking) model. During a command invocation, every <code>with-current-buffer</code> form obtains a lock for the buffer. All buffer locks are released at the end of command invocation. <code>on-pre-command</code> is run when the buffer lock is obtained for the first time and <code>on-post-command</code> is run when the buffer lock is released. When <code>with-current-buffer</code> runs outside any command invocation, it effectively starts a new command invocation for running its body and will run <code>on-pre-command</code> and <code>on-post-command</code> like normal command invocations. It's important to note the interaction between <code>with-current-buffer</code> and transactions.</p><dl><dt>Macro: <code>with-current-buffer</code> <code>(buffer &amp;body body)</code></dt><dd>Run BODY with BUFFER as the current buffer.</dd><dt>Progn generic function: <code>on-pre-command</code> <code>(buffer)</code></dt><dd>Run before command invocation.</dd><dd>More specifically, this runs before entering the first
<code>with-current-buffer</code> form for BUFFER during a command invocation.</dd><dt>Progn generic function: <code>on-post-command</code> <code>(buffer)</code></dt><dd>Run after command invocation.</dd><dd>More specifically, this runs after a command invocation iff it has
ever entered any <code>with-current-buffer</code> form for BUFFER during its
execution.</dd></dl><h2 id="condition-handling">Condition handling</h2><p>Normally, Neomacs command loop handles any error conditions that reach it. It runs approriate hook, logs a message, then continue processing the next command.</p><dl><dt>Variable: <code>*quit-hook*</code></dt><dd>Invoked when a quit condition reaches command loop.</dd><dd><code>user-error</code>s are considered quits and also trigger this hook.</dd><dt>Variable: <code>*error-hook*</code></dt><dd>Invoked when an error condition reaches command loop.</dd><dd><code>user-error</code>s are considered quits and does not trigger this hook.</dd></dl><p>It is also possible to ask the command loop to invoke the debugger instead of handling error conditions.</p><dl><dt>Variable: <code>*debug-on-error*</code></dt><dt>Command: <code>toggle-debug-on-error</code> <code>()</code></dt></dl><dl><dt>Class: <code>user-error</code> inherits <code>(error)</code></dt><dd>A user generated error.</dd><dd>This is normally treated the same as a <code>quit</code> condition and does not
drop into Neomacs debugger.</dd><dt>Function: <code>user-error</code> <code>(control-string &amp;rest format-arguments)</code></dt><dd>Signal a <code>simple-user-error</code> with messages formatted from
CONTROL-STRING and FORMAT-ARGUMENT.</dd><dt>Macro: <code>with-demoted-errors</code> <code>(prompt &amp;body body)</code></dt><dd>Run BODY and demote any error to simple messages.
Error messages are prepended with PROMPT.</dd><dd>If <code>*debug-on-error*</code> is t, run BODY without catching its errors.</dd></dl></body>